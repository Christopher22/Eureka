# Eureka

Even if the software "Robocode" seems on the first glance like a programming exercise for new software engineers, the tactical opportunities, complex situations and demanding challenges on a second prove this assumption wrong. Eureka is the attempt to build a highly modular foundation for a "rational" agent which can survive even in demanding circumstances of a melee battle. A key feature in achieving this goal is not only its ability to optimize his heuristics in battles but also tweaking its fundamental parameters between them using supervised and unsupervised machine learning approaches.

## Design

Eureka is not intended to be the best melee champion, victorious in every fight. The highly optimized robots nowadays being at the top of competitions seems to be rather excellent with their hard-wired logic. Just borrow their ideas to create a "Frankenbot," copying already proven ideas seems therefore rather dull. This bot should be different. It should have the ability to be flexible and adaptable for future use; suitable to be optimized for a 1-vs-1 exactly just like for melee battles or fight in teams. To achieve this goal of flexibility, two major concepts are used.

For adaptations on compile-time by the developer, Eureka is structured from the ground of according to well-tested design principles from the software development of the last years. With its complex and completely commented inheritance structure mimicking the human anatomy, every functionality of the robot is precisely encapsulated: While the "Leg" controls the actual movement of the robot, the "Eye" handles the surveillance of other robots and detects them if there are nearby. Besides, the "Fist" is used to abstract the concepts and tactics of attacking an enemy. It is crucial to understand that none of these components are "intelligent" or "rational" at all. They "just" handle their principal activities, and they should (hopefully) optimally handle them: The goal is to archive a high level of self-responsibility without an outer instance distracting them. This design allows to work and improve every part of the robot easily without the need of handling unforeseen side effects. On the other hand, these high autonomy "sub-agents" requires an extensive synchronizing between them far beyond the capabilities of the Robocode-way of handling events by overwriting functions. Instead, the well-known Observer pattern is used for that purpose: All components are sending and receiving signals and commands towards the "Brain" of Eureka, which works not only as an event manager forwarding the data to the other parts but also generating the actual, rational behavior.  The resulting network, where every part is asynchronously connected to every other member, shows obvious similarities with our human nervous system.

For adaptations at runtime by artificial intelligence, the extensive learning features of Eureka comes into account. This mechanic is the outstanding feature of Eureka, in this complexity used by almost no other robots. First of all, Eureka is capable of training itself unsupervised during battles. To do so, it evaluates the performance continuously regarding the survival of its enemies using a moving average approach and saves the results afterward. The gained information are used as heuristics in movement and attacking. While this tactic is well researched and used by other robots, Eureka combines it with its unique capability of being trained in the process of supervised learning, too. To do so, one needs to have a look at the way the robots stores its parameters. These "constants," which determine the exact way the robot behave, i.e., which distance is to be handled as "nearby" or which is the minimal distance the robot may move are not stored on a per-component basis. Instead, it is saved in the "Memory" of the robot together with the information, if the value is constant or may be adaptable in a specific range. The latter are the arguments which allow Eureka to optimize itself against determined enemies on the one hand and average battles in general. After being executed outside of a fight given a specific number of rounds and a list of opponents, it will then start thousands of battles where it tests all permutations of its parameter regarding its success measured by the score calculated by the engine using them. This brute-force-method guarantees that it will find not just a local optimum but the best solution of all, a human might not have seen before. The most successful set will afterward be stored and used in the next battles just like the additional gained heuristics of the other enemies, too.

## Strategy in battle

The classical strategies of Eureka are well researched and already applied by many other existing robots, except that there are enriched with the aforementioned ability to be improved over time, rounds and battles. The overall goal is the create an agent, which seems to learn and work rationally and reasonably. In consideration of the autonomy of the different components, it seems reasonable to have a look at each of them separately. 

As an optimal strategy for movement during the battle, Eureka uses an adaption of the "Minimum Risk Movement." It is intuitively clear that the best position in a confrontation is the point where the chance of winning (and not only surviving, other than the name suggests) is the highest one. To find such a point without being too predictable, Eureka spawns many possible waypoints around itself in a random distance and evaluates them afterward. The distance towards the current point (because one should never stay at the same position), the number of robots nearby, their current level of energy and their performance in the past battles are the basis of the heuristics. This movement is an improvement of the concept of "Anti-Gravity Movement" implemented in a previous version of this robot: The usage of heuristics to move away from possible sources of danger leads to the commonly known problem of getting stuck in corners. These may be the safest spot of a battlefield from a mathematical but not rational point of view. Eureka's approach resolves that issue by enforcing a specific distance towards the borders, paying this guarantee with a slower motion in comparison to other implementations. Moreover, positions directly before and behind the robot are forbidden for the sake of a nonlinear movement as protection against the predictions of advanced weapon systems resulting in some kind of "dancing." 

The gun of Eureka is implementing under the background of predictive shooting. If it is not aiming, its rotation is set to the direction of movement. Unlike the spinning implementation of early versions, these rotation allows an immediate response for the common case of enemies appearing in the area before the robot during movement. The best strategy of aiming seems to differ highly between 1-vs-1 battles and melee battles. The first used implementation considering the former position, speed, and velocity of enemies seem to be overwhelmed in the crowded situations with multiple robots around. Surprisingly, in a benchmark over 1000 rounds, a far simpler gun performed better than the compound system. The same observation is valid for a heuristics for the firepower. Instead of using a shifted sigmoid function to determine the power of a bullet as it was claimed in the draft, it just seems reasonable to fire with the maximum firepower. Due to the high chance of hitting some enemy simply due to their number on the battlefield even if this robot was not the targeted one, these "stupid" strategy was far more efficient than the "smart" one.

The radar is crucial for a robot like Eureka. Without a good overview of the battlefield, the tracking of robots over multiple turns and exact predictions of movement becomes rather challenging and error-prone. To cover an optimal field, three different movements of radar were evaluated: The simplest one just spin the radar infinitely in one direction, the more complex changes direction after each scan and the most advanced one biased the front of the robot to get these scanned more often than its back. While latter tactic was the best when using just the spinning, the current implementation combines the spinning approach with targeting. In case of the gun is aiming towards a target, the radar will focus there, too, to get additional information about the movement of the enemy. Due to the various targeting processes, a complex rotation strategy requiring adjustment every time after an enemy was attacked seems to lose its superiority about other radar maneuverings. Therefore, in order of simplicity after a benchmark with comparable results, the second solution was implemented.

## Performance & Further work

The current performance of Eureka is not far as good as it might be. Besides the automatic optimization of the parameters, it would be rather crucial to put some effort in the optimisation of the math behind heuristics; a process not easily automatable. As an example, a running average over the turns survived divided by the total amount of turns might be a good starting point for evaluating the performance of a robot, but ignores other important features. This evaluation is not straightforward, with every hand-operated benchmark testing a new method, a developer is in danger of just finding a local optimum. Furthermore, it is troublesome to believe that the trivial current implementation of the gun is the best one possible, a look towards more advanced strategies would be rather useful. Rarely occurring problems in the movement algorithm resulting in a situation of getting stuck in enemies need further optimization, too.

Nevertheless, it seems that the current performance is acceptable under the premise of building a robot for the experimentation with hand-written machine learning approaches. The next evolution of this concept would be even to remove the fixed implementation of behavior in "Brain" and change it with a dynamic strategy generated upon the evaluation of the commands and their success. In the current implementation of Eureka, the API and the data are ready for such an analysis and just waiting for an AI implementation - the battle for the throne of Robocode have only just begun.